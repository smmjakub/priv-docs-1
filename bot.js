const { Client, GatewayIntentBits } = require('discord.js');
const { IgApiClient } = require('instagram-private-api');
const mongoose = require('mongoose');
const http = require('http');
require('dotenv').config();

// Inicjalizacja klienta Discord
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.DirectMessages,
        GatewayIntentBits.GuildMembers
    ]
});

// Inicjalizacja Instagram API
const ig = new IgApiClient();

// Model u≈ºytkownika w MongoDB
const VerifiedUser = mongoose.model('VerifiedUser', {
    discordId: String,
    discordUsername: String,
    igUsername: String,
    verifiedAt: Date,
    guildId: String
});

// Mapa kod√≥w weryfikacyjnych
const verificationCodes = new Map();

// Po≈ÇƒÖczenie z MongoDB
mongoose.connect(process.env.MONGODB_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true
}).then(() => {
    console.log('Po≈ÇƒÖczono z MongoDB!');
}).catch(err => {
    console.error('B≈ÇƒÖd po≈ÇƒÖczenia z MongoDB:', err);
});

// Funkcje pomocnicze
function generateVerificationCode() {
    return Math.random().toString(36).substring(2, 8).toUpperCase();
}

async function isUserVerified(discordId) {
    return await VerifiedUser.exists({ discordId });
}

async function saveVerifiedUser(userData) {
    const newUser = new VerifiedUser(userData);
    await newUser.save();
}

// Walidacja konta Instagram
async function validateInstagramAccount(user) {
    try {
        const userInfo = await ig.user.info(user.pk);
        
        const criteria = {
            minFollowers: userInfo.follower_count >= 10,
            minFollowing: userInfo.following_count >= 5
        };

        const failedCriteria = Object.entries(criteria)
            .filter(([, passes]) => !passes)
            .map(([name]) => name);

        if (failedCriteria.length > 0) {
            let message = 'Twoje konto nie spe≈Çnia nastƒôpujƒÖcych wymaga≈Ñ:\n';
            failedCriteria.forEach(criteria => {
                switch(criteria) {
                    case 'minFollowers':
                        message += '- Minimum 10 followers√≥w\n';
                        break;
                    case 'minFollowing':
                        message += '- Musisz followowaƒá minimum 5 profili\n';
                        break;
                    case 'accountAge':
                        message += '- Konto musi byƒá starsze ni≈º 30 dni\n';
                        break;
                }
            });
            return { isValid: false, message };
        }

        return { isValid: true, message: 'Konto spe≈Çnia wymagania.' };
    } catch (error) {
        console.error('B≈ÇƒÖd walidacji konta:', error);
        return { isValid: false, message: 'WystƒÖpi≈Ç b≈ÇƒÖd podczas sprawdzania konta.' };
    }
}

// Sprawdzanie Instagrama
async function checkInstagramFollow(igUsername, verificationCode) {
    try {
        ig.state.generateDevice(process.env.IG_USERNAME);
        await ig.account.login(process.env.IG_USERNAME, process.env.IG_PASSWORD);
        
        const user = await ig.user.searchExact(igUsername);
        if (!user) {
            return { success: false, message: 'Nie znaleziono u≈ºytkownika na Instagramie.' };
        }

        const validation = await validateInstagramAccount(user);
        if (!validation.isValid) {
            return { success: false, message: validation.message };
        }

        const friendship = await ig.friendship.show(user.pk);
        if (!friendship.followed_by) {
            return { success: false, message: 'U≈ºytkownik nie followuje jeszcze profilu.' };
        }

        // Sprawd≈∫ wiadomo≈õci w g≈Ç√≥wnej skrzynce
        const inbox = await ig.feed.directInbox().items();
        let verificationMessage = inbox.find(thread => 
            thread.users[0].username.toLowerCase() === igUsername.toLowerCase() &&
            thread.last_permanent_item.text === verificationCode
        );

        // Sprawd≈∫ requesty wiadomo≈õci
        if (!verificationMessage) {
            const pendingInbox = await ig.feed.directPending().items();
            verificationMessage = pendingInbox.find(thread => 
                thread.users[0].username.toLowerCase() === igUsername.toLowerCase() &&
                thread.last_permanent_item.text === verificationCode
            );

            if (verificationMessage) {
                await ig.directThread.approve(verificationMessage.thread_id);
            }
        }

        if (!verificationMessage) {
            return { 
                success: false, 
                message: 'Nie znaleziono wiadomo≈õci z kodem weryfikacyjnym. Upewnij siƒô, ≈ºe wys≈Ça≈Çe≈õ kod w wiadomo≈õci prywatnej.' 
            };
        }

        return { success: true };
    } catch (error) {
        console.error('B≈ÇƒÖd weryfikacji Instagram:', error);
        return { 
            success: false, 
            message: 'WystƒÖpi≈Ç b≈ÇƒÖd podczas weryfikacji. Spr√≥buj ponownie za chwilƒô.' 
        };
    }
}

// Obs≈Çuga komend na serwerze
client.on('messageCreate', async (message) => {
    if (message.author.bot) return;

    // Komenda !verify na serwerze
    if (message.content === '!verify' && message.guild) {
        // Sprawd≈∫ czy u≈ºytkownik nie jest ju≈º zweryfikowany
        const isVerified = await isUserVerified(message.author.id);
        if (isVerified) {
            return message.reply('Jeste≈õ ju≈º zweryfikowany!');
        }

        const code = generateVerificationCode();
        verificationCodes.set(message.author.id, {
            code,
            timestamp: Date.now()
        });

        try {
            await message.author.send(
                `Witaj! Aby rozpoczƒÖƒá weryfikacjƒô:\n\n` +
                `1. Zaobserwuj profil **${process.env.IG_USERNAME}** na Instagramie\n` +
                `2. Wy≈õlij nastƒôpujƒÖcy kod w wiadomo≈õci prywatnej na Instagramie: **${code}**\n` +
                `3. Po wykonaniu powy≈ºszych krok√≥w, napisz tutaj: !verify <twoja_nazwa_u≈ºytkownika_instagram>\n\n` +
                `Kod jest wa≈ºny przez 30 minut.`
            );
            await message.reply('Wys≈Ça≈Çem instrukcje weryfikacji w prywatnej wiadomo≈õci! üì¨');
        } catch (error) {
            await message.reply('Nie mogƒô wys≈Çaƒá Ci prywatnej wiadomo≈õci. Upewnij siƒô, ≈ºe masz w≈ÇƒÖczone DM na tym serwerze.');
        }
    }

    // Komenda do sprawdzania zweryfikowanych u≈ºytkownik√≥w
    if (message.content === '!verified-users' && message.member.permissions.has('ADMINISTRATOR')) {
        const users = await VerifiedUser.find({ guildId: message.guild.id });
        
        if (users.length === 0) {
            return message.reply('Brak zweryfikowanych u≈ºytkownik√≥w.');
        }

        let reply = '**Zweryfikowani u≈ºytkownicy:**\n';
        for (const user of users) {
            reply += `- Discord: ${user.discordUsername}, Instagram: ${user.igUsername}, Data: ${user.verifiedAt.toLocaleDateString()}\n`;
        }
        
        await message.reply(reply);
    }
});

// Obs≈Çuga weryfikacji w DM
client.on('messageCreate', async (message) => {
    if (message.author.bot || message.guild) return;

    if (message.content.startsWith('!verify')) {
        const igUsername = message.content.split(' ')[1];
        
        if (!igUsername) {
            return message.reply('U≈ºyj: !verify <nazwa_u≈ºytkownika_instagram>');
        }

        const verification = verificationCodes.get(message.author.id);
        
        if (!verification) {
            return message.reply('Najpierw u≈ºyj komendy !verify na serwerze.');
        }

        if (Date.now() - verification.timestamp > 1800000) {
            verificationCodes.delete(message.author.id);
            return message.reply('Kod weryfikacyjny wygas≈Ç. U≈ºyj !verify ponownie na serwerze.');
        }

        const result = await checkInstagramFollow(igUsername, verification.code);

        if (result.success) {
            try {
                const guilds = client.guilds.cache;
                let verified = false;

                for (const [, guild] of guilds) {
                    try {
                        const member = await guild.members.fetch(message.author.id);
                        if (member) {
                            await member.roles.add(process.env.VERIFIED_ROLE_ID);
                            verified = true;

                            // Zapisz w bazie danych
                            await saveVerifiedUser({
                                discordId: message.author.id,
                                discordUsername: message.author.tag,
                                igUsername: igUsername,
                                verifiedAt: new Date(),
                                guildId: guild.id
                            });
                        }
                    } catch (e) {
                        console.error(`Nie mo≈ºna nadaƒá roli na serwerze ${guild.name}:`, e);
                    }
                }

                if (verified) {
                    verificationCodes.delete(message.author.id);
                    await message.reply('Weryfikacja udana! Nadano rolƒô. ‚úÖ');
                } else {
                    await message.reply('Weryfikacja siƒô powiod≈Ça, ale nie mogƒô znale≈∫ƒá Ciƒô na serwerze. Spr√≥buj ponownie p√≥≈∫niej.');
                }
            } catch (error) {
                console.error('B≈ÇƒÖd nadawania roli:', error);
                await message.reply('WystƒÖpi≈Ç b≈ÇƒÖd podczas nadawania roli.');
            }
        } else {
            await message.reply(`Weryfikacja nieudana: ${result.message}`);
        }
    }
});

// Serwer HTTP dla Render
const server = http.createServer((req, res) => {
    res.writeHead(200);
    res.end('Bot is running!');
});
server.listen(3000);

// Ping co 14 minut ≈ºeby bot nie zasypia≈Ç
setInterval(() => {
    http.get(`http://${process.env.RENDER_EXTERNAL_URL}`);
}, 840000);

client.once('ready', () => {
    console.log('Bot jest gotowy! üöÄ');
});

client.login(process.env.DISCORD_TOKEN);
